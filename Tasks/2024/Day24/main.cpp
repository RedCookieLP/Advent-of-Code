#include <AoC-Module.h>
#include <regex>
#include <unordered_map>
#include <map>
#include <array>

enum class LogicType
{
	AND,
	XOR,
	OR,
	CONSTANT
};
struct LogicGate
{
	LogicGate(const std::string& gateName = "", LogicType type = LogicType::AND)
		: gateName{gateName}, type{type}
	{}
	LogicGate(const std::string& gateName, bool outputConstant)
		: gateName{gateName}, type{LogicType::CONSTANT}, outputConstant{outputConstant}
	{}
	std::string gateName{};
	LogicGate* inputA{nullptr};
	LogicGate* inputB{nullptr};
	LogicType type{};
	bool outputConstant{false};
	inline bool output() const noexcept
	{
		bool aValue = (inputA && inputA->output());
		bool bValue = (inputB && inputB->output());
		switch (type)
		{
		case LogicType::AND:
			return aValue && bValue;
		case LogicType::XOR:
			return aValue != bValue;
		case LogicType::OR:
			return aValue || bValue;
		case LogicType::CONSTANT:
			return outputConstant;
		default:
			return false;
		}
	}
};

static std::unordered_map<std::string, LogicGate> s_allGates;

bool handleLine(const std::string& line)
{
	if (line == "")
		return true;
	
	static const std::regex INPUT_CONSTANT_REGEX{ R"(^([xy]\d{2}): ([01])$)" };
	static const std::regex LOGIC_GATE_REGEX{ R"(^([a-z0-9]{3}) (XOR|OR|AND) ([a-z0-9]{3}) -> ([a-z0-9]{3})$)" };

	std::smatch strMatch;
	if (std::regex_match(line, strMatch, INPUT_CONSTANT_REGEX))
	{
		std::string gateName = strMatch[1];
		bool constantValue = (strMatch[2].str()[0] == '1');
		s_allGates[gateName] = LogicGate(gateName, constantValue);
	}
	else if (std::regex_match(line, strMatch, LOGIC_GATE_REGEX))
	{
		std::string inputGateA = strMatch[1];
		std::string gateTypeStr = strMatch[2];
		std::string inputGateB = strMatch[3];
		std::string gateName = strMatch[4];

		auto iterToA = s_allGates.try_emplace(inputGateA).first;
		auto iterToB = s_allGates.try_emplace(inputGateB).first;

		LogicType gateType = (gateTypeStr == "AND" ? LogicType::AND : (gateTypeStr == "OR" ? LogicType::OR : LogicType::XOR));
		auto iterToSelf = s_allGates.insert_or_assign(gateName, LogicGate(gateName, gateType)).first;
		iterToSelf->second.inputA = &iterToA->second;
		iterToSelf->second.inputB = &iterToB->second;
	}
	else
	{
		std::cerr << "Line \"" << line << "\" doesn't match any regex!" << std::endl;
		return false;
	}
	return true;
}

void finalize()
{
#ifdef PART_1
	uint64_t zValue = 0ull;
	for (uint32_t zIndex = 64ull ; zIndex > 0ull ; zIndex--)
	{
		std::string key{"zXX "};
		std::snprintf(key.data()+1u, 3u, "%02u", zIndex-1u);
		key.pop_back();
		auto iter = s_allGates.find(key);
		if (iter != s_allGates.end())
			zValue = (zValue << 1u) | iter->second.output();
	}
	std::cout << "The value generated by all z-Nodes is " << zValue << std::endl;
#else
	std::cout << "I - like most people on the \"Advent-of-Code\"-reddit as well - have no idea how to solve this in code... and since I'm way too lazy/unmotivated to do it by hand, I've given up on Part 2 for now (or probably ever) :/" << std::endl;
#endif
}
